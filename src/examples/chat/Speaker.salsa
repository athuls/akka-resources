module examples.chat;
import java.util.Date;
import java.sql.Timestamp;
import java.util.Map;
import java.util.HashMap;
import examples.chat.ChatMessage.MessageType;
import java.util.Iterator;
import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;

// simple user class - this maintains an overall user implementation
behavior Speaker implements ActorService
{
	private String myName="";	
	Server server_ref;
	Map questionTimeStamp = new HashMap();
	Queue answerQueue = new LinkedList();
	ArrayList messages = new ArrayList();
	Queue messageQueue = new LinkedList();
	boolean isQuestion = false;
	ArrayList fifoValues = new ArrayList();
	ArrayList fifoMessageValues = new ArrayList();
	ArrayList valuesAdded = new ArrayList();

	// function used to set the identity of this user as someone questioning
	void setQuestionIdentity()
	{
		isQuestion = true;
	}

	// simple processing of the message by calling server's broadcast
	// this also prints out the timestamp at the beginning
	void broadcastSend(String msg, boolean is_statement, boolean is_question, boolean is_answer, int number_of_questions, int total_messages, boolean fifo) 
	{
		Date date = new Date();
		Timestamp current = new Timestamp(date.getTime());
		String type = "";
		if(is_statement)
			type = "STATEMENT";
		else if(is_question)
			type = "QUESTION";
		else if(is_answer)
			type = "ANSWER";
		standardOutput<-println("[Speaker Local] " + myName + ": " + type +": "+ msg + "; Timestamp: " + current) @ 
		server_ref<-broadcast(myName, msg, type, number_of_questions, total_messages, fifo);
	}	

	// this function handles messages accordingly by their type and adds them to the user's own chat message list - non single glitch
	void broadcastReceive(String speakerName, String msg, String type, int number_of_questions, int total_messages, boolean fifo) throws InterruptedException
	{
		switch (type)
		{
			case "QUESTION":				
				// add the question to the user's list
				messages.add(msg);
				Thread.sleep(200);

				// next mark the timestamp
				Date date_one = new Date();
				Timestamp current_one = new Timestamp(date_one.getTime());
				standardOutput<-println("[Speaker Remote] " + speakerName + ": " + type +": "+ msg + "; Timestamp: " + current_one);

				// put the question in the question map
				questionTimeStamp.put(msg, current_one);
				
				if (questionTimeStamp.values().size() == number_of_questions || isQuestion)
				{
					if(answerQueue.size() > 0)
					{
						// empty out queue
						while(answerQueue.size() > 0)
						{
							String chatMessage = (String) answerQueue.remove();

							// add the message to the list and print timestamp
							messages.add(chatMessage);
							Thread.sleep(200);
							Date date_two = new Date();
							Timestamp current_two = new Timestamp(date_two.getTime());
							standardOutput<-println("[Speaker Remote] " + speakerName + ": " + "ANSWER" +": "+ chatMessage + "; Timestamp: " + current_two);
						}						
					}
				}
				break;
			case "ANSWER":
				// check if there has been a question already placed
				if (questionTimeStamp.values().size() == number_of_questions || isQuestion)
				{
					if(answerQueue.size() > 0)
					{
						// empty out queue
						while(answerQueue.size() > 0)
						{
							String chatMessage = (String) answerQueue.remove();

							// add the message to the list and print timestamp
							messages.add(chatMessage);
							Thread.sleep(200);
							Date date_two = new Date();
							Timestamp current_two = new Timestamp(date_two.getTime());
							standardOutput<-println("[Speaker Remote] " + speakerName + ": " + "ANSWER" +": "+ chatMessage + "; Timestamp: " + current_two);
						}						
					}
					messages.add(msg);
					Thread.sleep(200);
					// get the time next
					Date date_three = new Date();
					Timestamp current_three = new Timestamp(date_three.getTime());
					standardOutput<-println("[Speaker Remote] " + speakerName + ": " + type +": "+ msg + "; Timestamp: " + current_three);
				}
				else
				{
					// store the message for later processing
					answerQueue.add(msg);
				}
				break;
			default:
				if(fifo)
				{
					Integer current_value = Integer.parseInt(msg.substring(10).replaceAll("[\\D]", ""));
					if(valuesAdded.size() == 0 || (Integer)valuesAdded.get(valuesAdded.size() - 1) == current_value - 1)
					{
						valuesAdded.add(current_value);
						messages.add(msg);
						Thread.sleep(200);

						// next mark the timestamp
						Date date_four = new Date();
						Timestamp current_four = new Timestamp(date_four.getTime());
						standardOutput<-println("[Speaker Remote] " + speakerName + ": " + type +": "+ msg + "; Timestamp: " + current_four);
						int i = -1;
						for(i = 0; i < fifoValues.size(); i++)
						{
							if((Integer)fifoValues.get(i) == current_value + 1)
							{
								current_value = (Integer)fifoValues.get(i);
								String current_message = (String)fifoMessageValues.get(i);
								messages.add(current_message);
								Thread.sleep(200);
								Date date_five = new Date();
								Timestamp current_five = new Timestamp(date_five.getTime());
								standardOutput<-println("[Speaker Remote] " + speakerName + ": " + "STATEMENT" +": "+ current_message + "; Timestamp: " + current_five);
							}
						}
						while(i > 0)
						{
							fifoMessageValues.remove(0);
							fifoValues.remove(0);
							i--;
						}
					}
					else
					{
						if(fifoValues.size() == 0)
						{
							fifoValues.add(current_value);
							fifoMessageValues.add(msg);
						}
						else
						{
							if(current_value < (Integer)fifoValues.get(0))
							{
								fifoValues.add(0, current_value);
								fifoMessageValues.add(0, msg);
							}
							else
							{
								for(int i = 0; i < fifoValues.size(); i++)
								{
									if(current_value > (Integer)fifoValues.get(i))
									{
										fifoValues.add(i, current_value);
										fifoMessageValues.add(i, msg);
										break;
									}
								}
							}
						}
					}
				}
				else
				{
					messages.add(msg);
					Thread.sleep(200);

					// next mark the timestamp
					Date date_four = new Date();
					Timestamp current_four = new Timestamp(date_four.getTime());
					standardOutput<-println("[Speaker Remote] " + speakerName + ": " + type +": "+ msg + "; Timestamp: " + current_four);
				}
				break;
		}

		// checks to see if program execution is completed
		/*
		if(messages.size() == total_messages)
		{
			standardOutput<-println("\nPrinting the final message list here: ");
			for(int i = 0; i < messages.size(); i++)
			{
				standardOutput<-println(messages.get(i));
			}
		}
		*/
	}

	// this function handles messages by their type and takes into account levels after causal consistency
	void broadcastReceiveAdvanced(String speakerName, String msg, String type, int number_of_questions, int total_messages, boolean fifo) throws InterruptedException
	{
		switch (type)
		{
			case "QUESTION":
				// add the question to the overall message list
				messageQueue.add(msg);

				// put the question in the question map
				Date date = new Date();
				Timestamp current = new Timestamp(date.getTime());
				questionTimeStamp.put(msg, current);
				
				if (questionTimeStamp.values().size() == number_of_questions || isQuestion)
				{
					if(answerQueue.size() > 0)
					{
						// empty out queue
						while(answerQueue.size() > 0)
						{
							String chatMessage = (String) answerQueue.remove();
							messageQueue.add(chatMessage);
						}						
					}
				}
				break;
			case "ANSWER":
				// check if there has been a question already placed
				if (questionTimeStamp.values().size() == number_of_questions || isQuestion)
				{
					if(answerQueue.size() > 0)
					{
						// empty out queue
						while(answerQueue.size() > 0)
						{
							String chatMessage = (String) answerQueue.remove();
							messageQueue.add(chatMessage);
						}						
					}
					messageQueue.add(msg);
				}
				else
				{
					// store the message for later processing
					answerQueue.add(msg);
				}
				break;
			default:
				// add the statement to the overall message queue
				messageQueue.add(msg);
				break;
		}

		// checks if all of the messages have arrived
		if(messageQueue.size() == total_messages)
		{
			while(messageQueue.size() > 0)
			{
				messages.add(messageQueue.remove());
				Thread.sleep(200);
			}
			Date date = new Date();
			Timestamp current = new Timestamp(date.getTime());
			standardOutput<-println("Overall Timestamp: " + current);
			for(int i = 0; i < messages.size(); i++)
			{
				standardOutput<-println(messages.get(i));
			}
		}
	}

	// print function to indicate a user is starting
	void whereAmI() 
	{
		standardOutput<-println("Speaker started with uan: "+ getUAN().toString());
	}	

	// sample starting function - does not serve much use
	void act(String args[])
	{
		if(args.length != 2)
		{
			standardOutput<-println("Usage: java -Duan=uan://hostname/place examples.chat.Speaker <serverName> <myName>");
			return;
		}
		
		myName=args[1];
		whereAmI();

		server_ref = (Server) Server.getReferenceByName(args[0]);
		server_ref<-registerUser(myName);
	}	
}